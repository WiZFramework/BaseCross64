/*!
@file Action.h
@brief アクション系コンポーネント
@copyright Copyright (c) 2017 WiZ Tamura Hiroki,Yamanoi Yasushi.
*/
#pragma once
#include "stdafx.h"

namespace basecross {

	//--------------------------------------------------------------------------------------
	///	アクション系コンポーネントの親クラス
	//--------------------------------------------------------------------------------------
	class ActionComponent : public Component {
	protected:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	プロテクトコンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit ActionComponent(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~ActionComponent();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Runフラグをセットする
		@param[in]	b	Runフラグ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRun(bool b);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	到着フラグをセットする
		@param[in]	b	到着フラグ
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetArrived(bool b);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	NowTimeを加算して、TotalTimeと比較する
		@return	到着していればtrue
		*/
		//--------------------------------------------------------------------------------------
		bool AdditionalNowTime();
	public:
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	実行中かどうかを得る
		@return	実行中ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsRun()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	実行中かどうかを得る
		@return	実行中ならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetRun()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	到着したかどうかを得る
		@return	到着したらtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsArrived()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	到着したかどうかを得る
		@return	到着したらtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetArrived()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	トータル時間を得る
		@return	このアクションのトータル時間
		*/
		//--------------------------------------------------------------------------------------
		virtual float GetTotalTime() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	トータル時間を設定する
		@param[in]	f	トータル時間
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void SetTotalTime(float f);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在時間を得る
		@return	このアクションの現在時間
		*/
		//--------------------------------------------------------------------------------------
		virtual float GetNowTime() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在時間を設定する
		@param[in]	f	現在時間
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void SetNowTime(float f);
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する（純粋仮想関数）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run() = 0;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを止める
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Stop();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを再スタートする
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void ReStart();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	描画、空関数（Drawは基本的に行わない）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDraw()override {}
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};

	//--------------------------------------------------------------------------------------
	///	アクションのインターバル（何もしないアクション）
	//--------------------------------------------------------------------------------------
	class ActionInterval : public  ActionComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit ActionInterval(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~ActionInterval();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータルタイム（何もしない時間）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
	};


	//--------------------------------------------------------------------------------------
	///	拡大縮小アクションの親クラス
	//--------------------------------------------------------------------------------------
	class ScaleComponent : public ActionComponent {
	protected:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	プロテクトコンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit ScaleComponent(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~ScaleComponent();
	public:
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	補間方法を得る
		@return	補間方法
		*/
		//--------------------------------------------------------------------------------------
		Lerp::rate GetRate() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	補間方法を設定する
		@param[in]	r	補間方法
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRate(const Lerp::rate r);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初のスケールを得る
		@return	最初のスケール
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetStartScale() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初のスケールを設定する
		@param[in]	StartScale	最初のスケール
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartScale(const bsm::Vec3& StartScale);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初のスケールを設定する
		@param[in]	x	Xスケーリング
		@param[in]	y	Yスケーリング
		@param[in]	z	Zスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartScale(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的のスケールを得る
		@return	目的のスケール
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetTargetScale() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的のスケールを設定する
		@param[in]	TargetScale	目的のスケール
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetScale(const bsm::Vec3& TargetScale);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的のスケールを設定する
		@param[in]	x	Xスケーリング
		@param[in]	y	Yスケーリング
		@param[in]	z	Zスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetScale(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在スケールを計算して返す。<br />
		タイムの更新は行わないので、Update後に呼ぶべき
		@return	現在スケール
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetNowScale() const;
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};

	//--------------------------------------------------------------------------------------
	///	目的の拡大率に拡大縮小
	//--------------------------------------------------------------------------------------
	class ScaleTo : public  ScaleComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit ScaleTo(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~ScaleTo();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	TargetScale	目的のスケーリング
		@param[in]	Rate = Lerp::Linear	補間方法（デフォルト線形）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& TargetScale, Lerp::rate Rate = Lerp::Linear);
	};

	//--------------------------------------------------------------------------------------
	///	目的の相対スケールにに拡大縮小
	//--------------------------------------------------------------------------------------
	class ScaleBy : public  ScaleComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit ScaleBy(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~ScaleBy();
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対スケールを得る
		@return	目的の相対スケール
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetLocalScale() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対スケールを設定する
		@param[in]	LocalScale	目的の相対スケール
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalScale(const bsm::Vec3& LocalScale);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対スケールを設定する
		@param[in]	x	Xスケーリング
		@param[in]	y	Yスケーリング
		@param[in]	z	Zスケーリング
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalScale(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	LocalScale	目的の相対スケーリング
		@param[in]	Rate = Lerp::Linear	補間方法（デフォルト線形）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& LocalScale, Lerp::rate Rate = Lerp::Linear);
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};

	//--------------------------------------------------------------------------------------
	///	回転アクションの親クラス
	//--------------------------------------------------------------------------------------
	class RotateComponent : public ActionComponent {
	protected:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	プロテクトコンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit RotateComponent(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~RotateComponent();
	public:
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初のクオータニオンを得る
		@return	最初のクオータニオン
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Quat& GetStartQuaternion() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初のクオータニオンを設定する
		@param[in]	Startbsm::Quat	最初のクオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartQuaternion(const bsm::Quat& StartQuaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の回転ベクトルを計算して得る。<br />
		内部で持っているのはクオータニオンなので計算したベクトルを返す。
		@return	最初の回転ベクトルを計算して返す
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetStartRotate() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	StartRotate	最初の回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartRotate(const bsm::Vec3& StartRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	x	X軸回転
		@param[in]	y	Y軸回転
		@param[in]	z	Z軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartRotate(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的のクオータニオンを得る
		@return	目的のクオータニオン
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Quat& GetTargetQuaternion() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的のクオータニオンを設定する
		@param[in]	Targetbsm::Quat	目的のクオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetQuaternion(const bsm::Quat& TargetQuaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の回転ベクトルを計算して得る。<br />
		内部で持っているのはクオータニオンなので計算したベクトルを返す。
		@return	目的の回転ベクトルを計算して返す
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetTargetRotate() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	TargetRotate	目的の回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetRotate(const bsm::Vec3& TargetRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	x	X軸回転
		@param[in]	y	Y軸回転
		@param[in]	z	Z軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetRotate(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在の回転ベクトルを計算して返す。回転は線形補間のみ対応する<br />
		タイムの更新は行わないので、Update後に呼ぶべき<br />
		内部で持っているのはクオータニオンなので、変換して返す。
		@return	現在の回転ベクトル
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetNowRotate() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在の回転クオータニオンを計算して返す。回転は線形補間のみ対応する<br />
		タイムの更新は行わないので、Update後に呼ぶべき
		@return	現在の回転クオータニオンを
		*/
		//--------------------------------------------------------------------------------------
		bsm::Quat GetNowQuaternion() const;
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};

	//--------------------------------------------------------------------------------------
	///	目的の角度に回転
	//--------------------------------------------------------------------------------------
	class RotateTo : public  RotateComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit RotateTo(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~RotateTo();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	TotalTime	トータル時間
		@param[in]	TargetRotate	目的の回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& TargetRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	Targetbsm::Quat	目的の回転クオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Quat& TargetQuaternion);
	};

	//--------------------------------------------------------------------------------------
	///	目的の相対角度に回転
	//--------------------------------------------------------------------------------------
	class RotateBy : public  RotateComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit RotateBy(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual	~RotateBy();
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対クオータニオンを得る
		@return	目的の相対クオータニオン
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Quat& GetLocalQuaternion() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対クオータニオンを設定する
		@param[in]	Localbsm::Quat	目的の相対クオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalQuaternion(const bsm::Quat& LocalQuaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対回転ベクトルを計算して得る。<br />
		内部で持っているのはクオータニオンなので計算したベクトルを返す。
		@return	目的の相対回転ベクトルを計算して返す
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetLocalRotate() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	LocalRotate	目的の相対回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalRotate(const bsm::Vec3& LocalRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対回転ベクトルを設定する。<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	x	X軸回転
		@param[in]	y	Y軸回転
		@param[in]	zZ軸回転
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalRotate(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する<br />
		内部で持っているのはクオータニオンなので、変換して設定する。
		@param[in]	TotalTime	トータル時間
		@param[in]	LocalRotate	目的の相対回転ベクトル
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& LocalRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	Localbsm::Quat	目的の相対回転クオータニオン
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Quat& LocalQuaternion);
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};





	//--------------------------------------------------------------------------------------
	///	移動アクションの親クラス
	//--------------------------------------------------------------------------------------
	class MoveComponent : public ActionComponent {
		void CalcVelocity();
		bsm::Vec3 CalcVelocitySub(float NowTime);
	protected:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	プロテクトコンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit MoveComponent(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~MoveComponent();
	public:
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	X方向の補間方法を得る
		@return	補間方法
		*/
		//--------------------------------------------------------------------------------------
		Lerp::rate GetRateX() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Y方向の補間方法を得る
		@return	補間方法
		*/
		//--------------------------------------------------------------------------------------
		Lerp::rate GetRateY() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Z方向の補間方法を得る
		@return	補間方法
		*/
		//--------------------------------------------------------------------------------------
		Lerp::rate GetRateZ() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	X方向の補間方法を設定する
		@param[in]	r	補間方法
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRateX(const Lerp::rate r);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Y方向の補間方法を設定する
		@param[in]	r	補間方法
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRateY(const Lerp::rate r);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	Z方向の補間方法を設定する
		@param[in]	r	補間方法
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRateZ(const Lerp::rate r);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XYZ全方向の補間方法を同じに設定する
		@param[in]	r	補間方法
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRateAll(const Lerp::rate r);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	XYZ全方向の補間方法を別々に設定する
		@param[in]	rX	補間方法X
		@param[in]	rY	補間方法Y
		@param[in]	rZ	補間方法Z
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetRateAll(const Lerp::rate rX, const Lerp::rate rY, const Lerp::rate rZ);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の位置を得る
		@return	最初の位置
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetStartPosition() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の位置を設定する
		@param[in]	StartPosition	位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartPosition(const bsm::Vec3& StartPosition);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	最初の位置を設定する
		@param[in]	x	位置X
		@param[in]	y	位置Y
		@param[in]	z	位置Z
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetStartPosition(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の位置を得る
		@return	目的の位置
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetTargetPosition() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の位置を設定する
		@param[in]	TargetPosition	位置
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetPosition(const bsm::Vec3& TargetPosition);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の位置を設定する
		@param[in]	x	位置X
		@param[in]	y	位置Y
		@param[in]	z	位置Z
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetTargetPosition(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在速度を計算して返す。<br />
		到着していたりRunしてなければ速度0を返す
		@return	現在速度
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetVelocity()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在位置を計算して返す。<br />
		タイムの更新は行わないのでUpdate後に呼ぶべき
		@return	現在速度
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetNowPosition() const;
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};

	//--------------------------------------------------------------------------------------
	///	目的の位置に移動
	//--------------------------------------------------------------------------------------
	class MoveTo : public  MoveComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit MoveTo(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~MoveTo();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	TargetPosition	目的の位置
		@param[in]	Rate = Lerp::Linear	補間方法（デフォルト線形）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& TargetPosition, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	TargetPosition	目的の位置
		@param[in]	RateX	X方向補間
		@param[in]	RateY	Y方向補間
		@param[in]	RateZ	Z方向補間
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& TargetPosition, Lerp::rate RateX, Lerp::rate RateY, Lerp::rate RateZ);
	};

	//--------------------------------------------------------------------------------------
	///	目的の相対位置に移動
	//--------------------------------------------------------------------------------------
	class MoveBy : public  MoveComponent {
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit MoveBy(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~MoveBy();
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対方向を得る
		@return	目的の相対方向
		*/
		//--------------------------------------------------------------------------------------
		const bsm::Vec3& GetLocalVector() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の位置を設定する
		@param[in]	LocalVector	相対方向
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalVector(const bsm::Vec3& LocalVector);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	目的の相対方向を設定する
		@param[in]	x	方向X
		@param[in]	y	方向Y
		@param[in]	z	方向Z
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLocalVector(float x, float y, float z);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	LocalVector	目的の相対方向
		@param[in]	Rate = Lerp::Linear	補間方法（デフォルト線形）
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& LocalVector, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	パラメータを設定する
		@param[in]	TotalTime	トータル時間
		@param[in]	LocalVector	目的の相対方向
		@param[in]	RateX	X方向補間
		@param[in]	RateY	Y方向補間
		@param[in]	RateZ	Z方向補間
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetParams(float TotalTime, const bsm::Vec3& LocalVector, Lerp::rate RateX, Lerp::rate RateY, Lerp::rate RateZ);
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run()override;
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};



	//--------------------------------------------------------------------------------------
	///	自動状態変更コンポーネント
	//--------------------------------------------------------------------------------------
	class Action : public Component {
		void RunSub(vector<shared_ptr<ActionComponent> >& TgtVector, size_t& TgtIndex);
		void StopSub(vector<shared_ptr<ActionComponent> >& TgtVector, size_t& TgtIndex);
		void ReStartSub(vector<shared_ptr<ActionComponent> >& TgtVector, size_t& TgtIndex);
		bool UpdateSub(vector<shared_ptr<ActionComponent> >& TgtVector, size_t& TgtIndex);
	public:
		//構築と破棄
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	GameObjectPtr	このコンポーネントを所持するゲームオブジェクト
		*/
		//--------------------------------------------------------------------------------------
		explicit Action(const shared_ptr<GameObject>& GameObjectPtr);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		virtual ~Action();
		//アクセサ
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ループするかどうかを得る
		@return	ループするならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsLooped()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ループするかどうかを得る
		@return	ループするならtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetLooped()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ループするかどうかを設定する
		@param[in]	b	ループするかどうか
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void SetLooped(bool b);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	到着したかどうかを得る<br />
		ループなしで到着したら真になる
		@return	到着したらtrue
		*/
		//--------------------------------------------------------------------------------------
		bool IsArrived()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	到着したかどうかを得る<br />
		ループなしで到着したら真になる
		@return	到着したらtrue
		*/
		//--------------------------------------------------------------------------------------
		bool GetArrived()const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	現在の速度を得る<br />
		Moveコンポーネントがない場合はbsm::Vec3(0,0,0)を返す
		@return	現在の速度
		*/
		//--------------------------------------------------------------------------------------
		bsm::Vec3 GetVelocity() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケーリングアクションの現在のインデックスを得る<br />
		スケーリングアクションが存在しなければ例外
		@return	現在のインデックス
		*/
		//--------------------------------------------------------------------------------------
		size_t GetScaleActiveIndex() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転アクションの現在のインデックスを得る<br />
		回転アクションが存在しなければ例外
		@return	現在のインデックス
		*/
		//--------------------------------------------------------------------------------------
		size_t GetRotateActiveIndex() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	移動アクションの現在のインデックスを得る<br />
		移動アクションが存在しなければ例外
		@return	現在のインデックス
		*/
		//--------------------------------------------------------------------------------------
		size_t GetMoveActiveIndex() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ScaleToアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	TargetScale	目的のスケール
		@param[in]	Rate = Lerp::Linear	補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ScaleTo> AddScaleTo(float TotalTime, const bsm::Vec3& TargetScale, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	ScaleByアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	LocalScale	目的の相対スケール
		@param[in]	Rate = Lerp::Linear	補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ScaleBy> AddScaleBy(float TotalTime, const bsm::Vec3& LocalScale, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief ScaleIntervalアクションを追加する
		@param[in]	TotalTime	かける時間
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionInterval> AddScaleInterval(float TotalTime);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	指定したインデックスのスケールコンポーネントを得る
		@param[in]	TargetIndex	取得するインデックス
		@return　指定したインデックスのスケールコンポーネント（アクションのポインタ）
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionComponent> GetScaleComponent(size_t TargetIndex) const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	T型にキャストした指定したインデックスのスケールコンポーネントを得る
		@tparam	T	スケール型
		@param[in]	TargetIndex	取得するインデックス
		@return	指定したインデックスのT型のコンポーネント
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		shared_ptr<T> GetScale(size_t TargetIndex) const {
			auto Ptr = GetScaleComponent(TargetIndex);
			auto Ptr2 = dynamic_pointer_cast<T>(Ptr);
			if (!Ptr2) {
				throw BaseException(
					L"そのコンポーネントはT型にキャストできません",
					Util::GetWSTypeName<T>(),
					L"Action::GetScale()"
				);
			}
			return Ptr2;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	スケールコンポーネントの配列を得る<br/>
		実際の配列が返るので慎重に操作すること
		@return	スケールコンポーネントの配列の参照
		*/
		//--------------------------------------------------------------------------------------
		vector<shared_ptr<ActionComponent>>& GetScaleVec() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	RotateToアクションを追加する<br/>
		内部で持っているのはクオータニオンなので、変換してセットする
		@param[in]	TotalTime	かける時間
		@param[in]	TargetRotate	目的の回転
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<RotateTo> AddRotateTo(float TotalTime, const bsm::Vec3& TargetRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	RotateToアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	Targetbsm::Quat	目的の回転クオータニオン
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<RotateTo> AddRotateTo(float TotalTime, const bsm::Quat& TargetQuaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	RotateByアクションを追加する<br/>
		内部で持っているのはクオータニオンなので、変換してセットする
		@param[in]	TotalTime	かける時間
		@param[in]	LocalRotate	目的の相対回転
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<RotateBy> AddRotateBy(float TotalTime, const bsm::Vec3& LocalRotate);
		//--------------------------------------------------------------------------------------
		/*!
		@brief　RotateByアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	Localbsm::Quat	目的の相対回転クオータニオン
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<RotateBy> AddRotateBy(float TotalTime, const bsm::Quat& LocalQuaternion);
		//--------------------------------------------------------------------------------------
		/*!
		@brief RotateIntervalアクションを追加する
		@param[in]	TotalTime	かける時間
		@return　追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionInterval> AddRotateInterval(float TotalTime);
		//--------------------------------------------------------------------------------------
		/*!
		@brief 指定したインデックスの回転コンポーネントを得る
		@param[in]	TargetIndex	取得するインデックス
		@return	指定したインデックスの回転コンポーネント（アクションのポインタ）
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionComponent> GetRotateComponent(size_t TargetIndex)const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	T型にキャストした指定したインデックスの回転コンポーネントを得る
		@tparam	T	回転型
		@param[in]	TargetIndex	取得するインデックス
		@return	指定したインデックスのT型のコンポーネント
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		shared_ptr<T> GetRotate(size_t TargetIndex)const {
			auto Ptr = GetRotateComponent(TargetIndex);
			auto Ptr2 = dynamic_pointer_cast<T>(Ptr);
			if (!Ptr2) {
				throw BaseException(
					L"そのコンポーネントはT型にキャストできません",
					Util::GetWSTypeName<T>(),
					L"Action::GetRotate()"
				);
			}
			return Ptr2;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	回転コンポーネントの配列を得る<br/>
		実際の配列が返るので慎重に操作すること
		@return	回転コンポーネントの配列の参照
		*/
		//--------------------------------------------------------------------------------------
		vector<shared_ptr<ActionComponent>>& GetRotateVec() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	MoveToアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	TargetPosition	目的の位置
		@param[in]	Rate = Lerp::Linear	補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<MoveTo> AddMoveTo(float TotalTime, const bsm::Vec3& TargetPosition, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	MoveToアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	TargetPosition	目的の位置
		@param[in]	RateX	X補間方法
		@param[in]	RateY	Y補間方法
		@param[in]	RateZ	Z補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<MoveTo> AddMoveTo(float TotalTime, const bsm::Vec3& TargetPosition, Lerp::rate RateX, Lerp::rate RateY, Lerp::rate RateZ);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	MoveByアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	LocalVector	目的の相対位置
		@param[in]	Rate = Lerp::Linear	補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<MoveBy> AddMoveBy(float TotalTime, const bsm::Vec3& LocalVector, Lerp::rate Rate = Lerp::Linear);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	MoveByアクションを追加する
		@param[in]	TotalTime	かける時間
		@param[in]	LocalVector	目的の相対位置
		@param[in]	RateX	X補間方法
		@param[in]	RateY	Y補間方法
		@param[in]	RateZ	Z補間方法
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<MoveBy> AddMoveBy(float TotalTime, const bsm::Vec3& LocalVector, Lerp::rate RateX, Lerp::rate RateY, Lerp::rate RateZ);
		//--------------------------------------------------------------------------------------
		/*!
		@brief	MoveIntervalアクションを追加する
		@param[in]	TotalTime	かける時間
		@return	追加したアクションのポインタ
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionInterval> AddMoveInterval(float TotalTime);
		//--------------------------------------------------------------------------------------
		/*!
		@brief 指定したインデックスの移動コンポーネントを得る
		@param[in]	TargetIndex	取得するインデックス
		@return	指定したインデックスの移動コンポーネント（アクションのポインタ）
		*/
		//--------------------------------------------------------------------------------------
		shared_ptr<ActionComponent> GetMoveComponent(size_t TargetIndex)const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief T型にキャストした指定したインデックスの移動コンポーネントを得る
		@tparam	T	移動型
		@param[in]	TargetIndex	取得するインデックス
		@return	指定したインデックスのT型のコンポーネント
		*/
		//--------------------------------------------------------------------------------------
		template<typename T>
		shared_ptr<T> GetMove(size_t TargetIndex)const {
			auto Ptr = GetMoveComponent(TargetIndex);
			auto Ptr2 = dynamic_pointer_cast<T>(Ptr);
			if (!Ptr2) {
				throw BaseException(
					L"そのコンポーネントはT型にキャストできません",
					Util::GetWSTypeName<T>(),
					L"Action::GetMove()"
				);
			}
			return Ptr2;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	移動コンポーネントの配列を得る<br/>
		実際の配列が返るので慎重に操作すること
		@return	移動コンポーネントの配列の参照
		*/
		//--------------------------------------------------------------------------------------
		vector<shared_ptr<ActionComponent>>& GetMoveVec() const;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	すべてのアクションをクリアする
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void AllActionClear();
		//操作
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを実行する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Run();
		//--------------------------------------------------------------------------------------
		/*!
		@brief アクションを止める
		@return　なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void Stop();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	アクションを再スタートする
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void ReStart();
		//--------------------------------------------------------------------------------------
		/*!
		@brief	更新処理
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnUpdate()override;
		//--------------------------------------------------------------------------------------
		/*!
		@brief	描画処理。空関数
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		virtual void OnDraw()override {}
	private:
		// pImplイディオム
		struct Impl;
		unique_ptr<Impl> pImpl;
	};




}
//end basecross